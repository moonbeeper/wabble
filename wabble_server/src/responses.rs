use axum::extract::ws::Message;

use crate::room::Room;

#[derive(
    Debug,
    Clone,
    Copy,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    serde_repr::Serialize_repr,
    serde_repr::Deserialize_repr,
)]
#[repr(u16)]
pub enum Opcode {
    Handshake = 0,
    Persona = 1,
    JoinRoom = 2,
    SendMessage = 3,
    EchoMessage = 4,
}

pub trait TSocketResponse {
    fn opcode(&self) -> Opcode;
}

#[derive(Debug, serde::Serialize)]
pub struct SocketResponse<D = serde_json::Value> {
    #[serde(rename = "op")]
    pub opcode: Opcode,
    pub data: D,
}

impl<D: TSocketResponse> SocketResponse<D> {
    pub fn new(data: D) -> Self {
        Self {
            opcode: data.opcode(),
            data,
        }
    }
}

impl<D: TSocketResponse + serde::Serialize> From<SocketResponse<D>> for Message {
    fn from(val: SocketResponse<D>) -> Self {
        Message::Text(
            serde_json::to_string(&val)
                .expect("failed serializing socket response")
                .into(),
        )
    }
}

#[derive(Debug, serde::Serialize)]
pub struct Handshake {
    pub heartbeat_interval: u16,
    pub active_connections: usize,
    pub public_rooms: Vec<PublicRoomInfo>,
}

impl TSocketResponse for Handshake {
    fn opcode(&self) -> Opcode {
        Opcode::Handshake
    }
}

#[derive(Debug, serde::Serialize)]
pub struct PublicRoomInfo {
    pub id: uuid::Uuid,
    pub name: String,
    pub active_connections: usize,
    pub max_connections: usize,
}

impl From<&Room> for PublicRoomInfo {
    fn from(value: &Room) -> Self {
        Self {
            id: value.id,
            name: value.name.clone(),
            active_connections: value.current_connections(),
            max_connections: value.max_connections,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize)]
pub struct Persona {
    pub name: String,  // display name that can collide. differentiated via the color
    pub color: String, // hex rrggbbaa, probably autogenerated if not provided
}

impl TSocketResponse for Persona {
    fn opcode(&self) -> Opcode {
        Opcode::Persona
    }
}

#[derive(Debug, serde::Deserialize)]
pub struct JoinRoom {
    pub id: uuid::Uuid,
}

impl TSocketResponse for JoinRoom {
    fn opcode(&self) -> Opcode {
        Opcode::JoinRoom
    }
}

#[derive(Debug, serde::Deserialize)]
pub struct SendMessage {
    pub message: String,
    pub drawing: Option<Vec<u8>>, // optional drawing data, probably RLE encoded to tinify it
}

impl TSocketResponse for SendMessage {
    fn opcode(&self) -> Opcode {
        Opcode::SendMessage
    }
}

#[derive(Debug, serde::Serialize)]
pub struct EchoMessage {
    pub id: uuid::Uuid,
    pub persona: Persona,
}

impl TSocketResponse for EchoMessage {
    fn opcode(&self) -> Opcode {
        Opcode::EchoMessage
    }
}
