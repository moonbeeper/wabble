use axum::extract::ws::Message;

use crate::room::{self, MessagePersona, Room};

#[derive(
    Debug,
    Clone,
    Copy,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    serde_repr::Serialize_repr,
    serde_repr::Deserialize_repr,
)]
#[repr(u16)]
pub enum Opcode {
    Handshake = 0,
    Persona = 1,
    JoinRoom = 2,
    SendMessage = 3,
    EchoMessage = 4,
    WhoAmI = 6,
    ServerPopulation = 7,
    PublicRoomStatus = 8,
}

pub trait SocketResponse: std::fmt::Debug {
    fn opcode(&self) -> Opcode;
}

#[derive(Debug, serde::Serialize, serde::Deserialize)]
pub struct SocketComms<D = serde_json::Value> {
    #[serde(rename = "op")]
    pub opcode: Opcode,
    pub data: Option<D>,
}

impl<D: SocketResponse> SocketComms<D> {
    pub fn new(data: D) -> Self {
        Self {
            opcode: data.opcode(),
            data: Some(data),
        }
    }
}

impl<D: SocketResponse + serde::Serialize> From<SocketComms<D>> for Message {
    fn from(val: SocketComms<D>) -> Self {
        Message::Text(
            serde_json::to_string(&val)
                .expect("failed serializing socket response")
                .into(),
        )
    }
}

#[derive(Debug, serde::Serialize)]
pub struct Handshake {
    pub session_id: uuid::Uuid,
    pub heartbeat_interval: u16,
    pub active_connections: usize,
    pub public_rooms: Vec<PublicRoomInfo>,
}

impl SocketResponse for Handshake {
    fn opcode(&self) -> Opcode {
        Opcode::Handshake
    }
}

#[derive(Debug, serde::Serialize, serde::Deserialize)]
pub struct PublicRoomInfo {
    pub id: mtid::Ttid,
    pub name: String,
    pub active_connections: usize,
    pub max_connections: usize,
}

impl From<&Room> for PublicRoomInfo {
    fn from(value: &Room) -> Self {
        Self {
            id: value.id.id(),
            name: value.name.clone(),
            active_connections: value.current_connections(),
            max_connections: value.max_connections,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize)]
pub struct Persona {
    pub name: Option<String>, // display name that can collide. differentiated via the color
    pub color: Option<String>, // hex rrggbbaa, probably autogenerated if not provided
}

impl SocketResponse for Persona {
    fn opcode(&self) -> Opcode {
        Opcode::Persona
    }
}

impl From<room::Persona> for Persona {
    fn from(persona: room::Persona) -> Self {
        Self {
            name: Some(persona.name.clone()),
            color: Some(
                persona
                    .forced_color
                    .as_ref()
                    .unwrap_or(&persona.color)
                    .clone(),
            ),
        }
    }
}

#[derive(Debug, serde::Deserialize)]
pub struct JoinRoom {
    pub id: mtid::Ttid,
}

impl SocketResponse for JoinRoom {
    fn opcode(&self) -> Opcode {
        Opcode::JoinRoom
    }
}

#[derive(Debug, serde::Deserialize)]
pub struct SendMessage {
    pub message: String,
    pub drawing: Option<String>, // optional drawing data, probably RLE encoded to tinify it
}

impl SocketResponse for SendMessage {
    fn opcode(&self) -> Opcode {
        Opcode::SendMessage
    }
}

#[derive(Debug, serde::Serialize)]
pub struct EchoMessage {
    pub message: String,
    pub drawing: Option<String>,
    pub persona: MessagePersona,
}

impl SocketResponse for EchoMessage {
    fn opcode(&self) -> Opcode {
        Opcode::EchoMessage
    }
}

impl From<room::RoomMessage> for EchoMessage {
    fn from(value: room::RoomMessage) -> Self {
        Self {
            message: value.message,
            drawing: value.drawing,
            persona: MessagePersona {
                id: value.persona.id,
                name: value.persona.name,
                color: value.persona.color,
            },
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize)]
pub struct WhoAmI {
    pub persona: Persona,
}

impl SocketResponse for WhoAmI {
    fn opcode(&self) -> Opcode {
        Opcode::WhoAmI
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize)]
pub struct ServerPopulation {
    pub pop: usize,
}

impl SocketResponse for ServerPopulation {
    fn opcode(&self) -> Opcode {
        Opcode::ServerPopulation
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize)]
pub struct PublicRoomStatus {
    pub public_rooms: Vec<PublicRoomInfo>,
}

impl SocketResponse for PublicRoomStatus {
    fn opcode(&self) -> Opcode {
        Opcode::PublicRoomStatus
    }
}

// #[derive(Debug, serde::Deserialize)]
// pub struct CreateRoom;

// impl SocketResponse for CreateRoom {
//     fn opcode(&self) -> Opcode {
//         Opcode::CreateRoom
//     }
// }
